---
title: Fetch JWST TSO programs from STScI
page-navigation: true
---

This Python script shows how to fetch and parse the entire catalog of JWST TSO
prgrams from the STScI website.

This tutorial is split into three sections:

- [Fetch TSO files](#fetch-tso-files)
- [Parse to database](#parse-files-to-database)
- [Playground](#playground)

<br>

## Fetch TSO files

STScI [provides](https://www.stsci.edu/jwst-program-info/search) the
information for each JWST program in two files:

- the Astronomers Proposal Tool (APT) file (in .aptx format)
- the status file (in .xml format)

The APT files have to be then converted .xml format to be further parsed.
This can be done using the STScI's [APT
software](https://www.stsci.edu/scientific-community/software/astronomers-proposal-tool-apt).
This will be done under the hood by ``Gen TSO``, all we need to set is the
path to the APT executable:

::: {.panel-tabset}

## APT on OSX

After you installed APT, search in your Application folders.
The executable will be located inside the `bin` subfolder. We will need to
get the absolute path to it, It should be something like:

```bash
/Applications/APT\\ 2024.7.1/bin/apt
```

The following script shows how to fetch the APT and status for the programs:

```python
import gen_tso.catalogs as cat

# Path to APT executable:
apt_command = '/Applications/APT\\ 2024.7.1/bin/apt'

# Fetch all TSO programs:
cat.fetch_jwst_programs(apt_command)
```

## APT on Linux

After you installed APT on Linux, search for the folder where it was
installed.  The path to the executable should be something like this:

```bash
/home/user/ast/apt/APT_2024.5.2/APT
```

The following script shows how to fetch the APT and status for the programs:

```python
import gen_tso.catalogs as cat

# Path to APT executable:
apt_command = '/home/user/ast/apt/APT_2024.5.2/APT'

# Fetch all TSO programs:
cat.fetch_jwst_programs(apt_command)
```

## Environmental variable

Either on a Linux or OSX machine, if you create an environmental variable
in your bash, e.g.:

```bash
export APT='/home/user/ast/apt/APT_2024.5.2/APT'
```
then you can directly use that environmental variable.
The following script shows how to fetch the APT and status for the programs:

```python
import gen_tso.catalogs as cat

# APT's environmental variable:
apt_command = 'APT'

# Fetch all TSO programs:
cat.fetch_jwst_programs(apt_command)
```

:::

To process one program takes a few seconds. Thus, to process the entire
catalog will take some ~10 min.

If you want to only fetch specific programs, you can use the `programs`
argument with the desired PID(s):

```python
import gen_tso.catalogs as cat

# Fetch a single program
apt_command = 'APT'
programs = 3712
cat.fetch_jwst_programs(apt_command, programs)


# Fetch a set of programs
programs = [2759, 3557, 3730, 4098]
cat.fetch_jwst_programs(apt_command, programs)
```

::: {.callout-note}
By default, the `cat.fetch_jwst_programs()` function will store the
files into a default folder inside the `Gen TSO` package, you can find
that folder with this script:

```python
from gen_tso import ROOT
print(f'{ROOT}data/programs/')
```

To place them to a custom folder, use the `output_folder` argument.
:::



## Parse files to database

Once we have downloaded the .xml files for the JWST TSO programs,
we can parse them to a human readable format.  Here's how:

```python
import pickle
from gen_tso import catalogs as cat
from gen_tso.utils import KNOWN_PROGRAMS

# Parse and collect the observations from all known programs
observations = []
for program in KNOWN_PROGRAMS:
    observations += cat.parse_program(program)
```

That's all.  Now we can take a look or save the outputs, e.g.:

```python
# Save to pickle file
with open('JWST_TSO_programs.pickle', 'wb') as handle:
    pickle.dump(observations, handle, protocol=4)

# Print the content of one observation:
for key, val in observations[98].items():
    print(f'{key} = {repr(val)}')
```
::: {.cell-output-stdout}
```
category = 'ERS'
pi = 'Batalha'
pid = '1366'
proprietary = '0'
special_reqs = ['OrientRange', 'PeriodZeroPhase', 'TimeSeriesObservation']
observation = '3'
visit = '1'
status = 'Executed'
hours = 10.56
start = datetime.datetime(2022, 7, 30, 20, 46, 32)
end = datetime.datetime(2022, 7, 31, 6, 21, 30)
label = 'Transmission - WASP-39b : nirspec g395h'
target = 'WASP-39'
RA = '14:29:18.3955'
dec = '-03:26:40.20'
instrument = 'NIRSPEC'
mode = 'BOTS'
disperser = 'G395H'
filter = 'F290LP'
subarray = 'SUB2048'
readout = 'NRSRAPID'
groups = '70'
integrations = '465'
reqs_phase = {'ZeroPhase': '2457792.356338', 'Period': '4.05527999 Days', 'PhaseStart': '0.95248', 'PhaseEnd': '0.96275'}
period = 4.05527999
phase_start = 0.957615
phase_duration = 0.10850052304279982
event = 'transit'
```
:::


```python
nobs = len(observations)

# Find the planet
from gen_tso.catalogs import load_trexolists, Catalog
catalog = Catalog()
targets = [
    target for target in catalog.targets
    if target.is_jwst
]

for o in obs:
    planets = p.get_planet_letters(o, targets, verbose=False)
    o['planets'] = planets
    pid = o['pid']
    oid = o['observation']
    target = o['target']
    event = o['event']
    print(f"{pid} {oid:3} {target:20s} {event:11}  {planets}")
```

```python
# Compare to trexolists
trexo = load_trexolists()
t_programs = trexo['program']
t_obs = trexo['observation']
t_visit = trexo['visit']
t_event = trexo['event']
n_trexo = len(t_programs)
for i in range(n_trexo):
    p = t_programs[i].split()[1]
    o = str(t_obs[i])
    v = str(t_visit[i])
    e = str(t_event[i])
    e = 'phase curve' if e == 'phase' else e
    missing = True
    for ob in obs:
        if ob['pid']==p and ob['observation']==o and ob['visit']==v:
            missing = False
            if ob['event'] != e:
                print(f"diff {p} {o:3} {repr(ob['event'])} -- {repr(e)}")
            break
    if missing:
        print(f'Missing: {p} {o} {v}')
for ob in obs:
    missing = True
    for i in range(n_trexo):
        p = t_programs[i].split()[1]
        o = str(t_obs[i])
        v = str(t_visit[i])
        if ob['pid']==p and ob['observation']==o and ob['visit']==v:
            missing = False
            break
    if missing:
        p = ob['pid']
        o = ob['observation']
        v= ob['visit']
        print(f'New: {p} {o} {v}')
```

```python
# Plot orbital phase coverage
periods = [
    o['period'] if 'phase_duration' in o else 0
    for o in obs
]
log_period = np.log10(periods)
max_period = np.amax(log_period)
max_period = 1.5

fig = plt.figure(0)
plt.clf()
plt.subplots_adjust(0.1, 0.1, 0.98, 0.98)
fig.set_size_inches(6,6)
plt.axvline(1, color='r', zorder=-1)
plt.axvline(2, color='r', zorder=-1)
plt.axvline(0.5, color='k', zorder=-1)
plt.axvline(1.5, color='k', zorder=-1)
plt.axvline(2.5, color='k', zorder=-1)
for i in range(nobs):
    if 'phase_duration' not in obs[i]:
        continue
    phase = obs[i]['phase0']
    duration = obs[i]['phase_duration']
    plt.broken_barh(
        [(phase, duration)], (i, 1),
        color=plt.cm.viridis_r(log_period[i]/max_period),
    )
    color = 'k' if obs[i]['event']=='transit' else 'r'
    if obs[i]['event']=='phase curve':
        color = 'xkcd:blue'
    plt.text(phase, i, obs[i]['target'] + ' ' +obs[i]['pid'], color=color)
plt.ylim(0, nobs+1)
```

## Playground

The latest TSO run for a given Pandeia object can be saved with this method: 
```python
pando.save_tso(filename='tso_transit_WASP-80b_nircam_lw_f444w.picke')
```

See [this tutorial](tutorials_tso_post_processing.qmd) to load that pickle file and simulate some spectra.

Now lets set up a NIRCam/F444W observation and run the TSO calculation.
First, we need to know what are the available options.  These are the
instruments and their respective modes:


